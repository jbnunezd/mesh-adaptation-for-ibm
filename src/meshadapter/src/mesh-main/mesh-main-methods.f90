!======================================================================================================================!
!
! IBM-MESH-ADAPTATION-TOOL
!
! Copyright (c) 2020 by Jonatan Nunez
!
! This program is free software: you can redistribute it and/or modify it under the terms of the GNU 
! General Public License as published by the Free Software Foundation, either version 3 of the License, 
! or (at your option) any later version.
! 
! This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even 
! the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
! See the GNU General Public License for more details.
! 
! You should have received a copy of the GNU General Public License along with this program.
! If not, see <https://www.gnu.org/licenses/>.
!
!======================================================================================================================!
!
!======================================================================================================================!
#include "main.h"
!======================================================================================================================!
!
!======================================================================================================================!
MODULE MOD_MeshMainMethods
!----------------------------------------------------------------------------------------------------------------------!
USE MOD_GLOBAL_vars
!----------------------------------------------------------------------------------------------------------------------!
USE MOD_MeshMain_vars
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
PUBLIC
!----------------------------------------------------------------------------------------------------------------------!
!
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE CreateElem
  MODULE PROCEDURE CreateElem
END INTERFACE

INTERFACE RemoveElem
  MODULE PROCEDURE RemoveElem
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE CreateSide
  MODULE PROCEDURE CreateSide
END INTERFACE

INTERFACE CreateBC
  MODULE PROCEDURE CreateBC
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE CreateNode
  MODULE PROCEDURE CreateNode
END INTERFACE

INTERFACE AddDataToNode
  MODULE PROCEDURE AddDataToNode
END INTERFACE

INTERFACE GetNodeData
  MODULE PROCEDURE GetNodeData
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE CreateHexaElem
  MODULE PROCEDURE CreateHexaElem
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE CountNodes
  MODULE PROCEDURE CountNodes
END INTERFACE

INTERFACE CountElems
  MODULE PROCEDURE CountElems
END INTERFACE

INTERFACE CountElemID
  MODULE PROCEDURE CountElemID
END INTERFACE

INTERFACE CountElemsByLevel
  MODULE PROCEDURE CountElemsByLevel
END INTERFACE

INTERFACE CountBCFaces
  MODULE PROCEDURE CountBCFaces
END INTERFACE

INTERFACE SetAndCountNodeID
  MODULE PROCEDURE SetAndCountNodeID
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE AddElemToList
  MODULE PROCEDURE AddElemToList
END INTERFACE

INTERFACE PrintElemList
  MODULE PROCEDURE PrintElemList
END INTERFACE

INTERFACE DestructElemList
  MODULE PROCEDURE DestructElemList
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE CreateFaceNodes
  MODULE PROCEDURE CreateFaceNodes
END INTERFACE

INTERFACE GetFaceNodesData
  MODULE PROCEDURE GetFaceNodesData
END INTERFACE

INTERFACE AddFaceNodesToList
  MODULE PROCEDURE AddFaceNodesToList
END INTERFACE

INTERFACE PrintFaceNodesList
  MODULE PROCEDURE PrintFaceNodesList
END INTERFACE

INTERFACE DestructFaceNodesList
  MODULE PROCEDURE DestructFaceNodesList
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
INTERFACE GetQuad4QuadMap
  MODULE PROCEDURE GetQuad4QuadMap
END INTERFACE
!----------------------------------------------------------------------------------------------------------------------!
!
!
!
!======================================================================================================================!
CONTAINS
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateNode(Node,RefCount)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tNode),POINTER,INTENT(INOUT) :: Node
INTEGER,OPTIONAL,INTENT(IN)       :: RefCount
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

ALLOCATE(Node)
Node%NodeID = 0
Node%BCFlag = 0

IF(PRESENT(RefCount)) THEN
  Node%RefCount = RefCount
ELSE
  Node%RefCount = 0
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateNode
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateNodeAndSetNodeID(Node,NodeID)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tNode),POINTER,INTENT(INOUT) :: Node
INTEGER,OPTIONAL,INTENT(INOUT)    :: NodeID
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

CALL CreateNode(Node)

NodeID      = NodeID+1
Node%NodeID = NodeID

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateNodeAndSetNodeID
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE AddDataToNode(Node,NodeID,Coords)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tNode),INTENT(INOUT) :: Node 
INTEGER,INTENT(IN)        :: NodeID
REAL,INTENT(IN)           :: Coords(1:3)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

Node%NodeID = NodeID
Node%Coords = Coords

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE AddDataToNode
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE GetNodeData(Node,NodeID,Coords)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tNode),INTENT(IN)       :: Node
INTEGER,OPTIONAL,INTENT(OUT) :: NodeID
REAL,OPTIONAL,INTENT(OUT)    :: Coords(1:3)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

IF (PRESENT(NodeID)) THEN
  NodeID = Node%NodeID
END IF

IF (PRESENT(Coords)) THEN
  Coords = Node%Coords
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE GetNodeData
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateElem(Elem)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER,INTENT(INOUT) :: Elem
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

ALLOCATE(Elem)

NULLIFY(Elem%PrevElem)
NULLIFY(Elem%NextElem)
NULLIFY(Elem%FirstSide)

NULLIFY(Elem%Nodes)

Elem%nNodes       = 0
Elem%Flag         = 0
Elem%TreeID       = 0
Elem%ParentID     = 0
Elem%ElemID       = 0
Elem%LocChild     = 0
Elem%Level        = 0
Elem%nPoints      = 0
Elem%nFacets      = 0

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateElem
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE DestructElemList(ElemList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElemList),INTENT(INOUT) :: ElemList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
TYPE(tElem),POINTER :: bElem
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(ElemList%FirstElem)) THEN
  RETURN
END IF

aElem => ElemList%FirstElem
DO WHILE(ASSOCIATED(aElem))
  bElem => aElem%NextElem
  CALL RemoveElem(aElem,ElemList)
  aElem => bElem
END DO

NULLIFY(ElemList%FirstElem)
NULLIFY(ElemList%LastElem)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE DestructElemList
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE AddElemToList(Elem,ElemList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER,INTENT(INOUT) :: Elem
TYPE(tElemList),INTENT(INOUT)     :: ElemList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

Elem%PrevElem => ElemList%LastElem
NULLIFY(Elem%NextElem)

IF (.NOT. ASSOCIATED(ElemList%LastElem)) THEN
  ElemList%FirstElem => Elem
  ElemList%LastElem  => Elem
ELSE
  ElemList%LastElem%NextElem => Elem
END IF

ElemList%LastElem => Elem

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE AddElemToList
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE PrintElemList()
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iNode
INTEGER :: ElemID
INTEGER :: TreeID
INTEGER :: ParentID
!----------------------------------------------------------------------------------------------------------------------!
REAL,ALLOCATABLE :: CornerCoords(:,:)
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
TYPE(tSide),POINTER :: aSide
!----------------------------------------------------------------------------------------------------------------------!

ALLOCATE(CornerCoords(1:8,1:3))

aElem => ElemList%FirstElem
DO WHILE(ASSOCIATED(aElem))
  ElemID   = aElem%ElemID
  TreeID   = aElem%TreeID
  ParentID = aElem%ParentID
  DO iNode=1,aElem%nNodes
    CornerCoords(iNode,1:3) = aElem%Nodes(iNode)%Node%Coords(1:3)
  END DO
  WRITE(UNIT_SCREEN,'(2X,A,I0)') "ParentID = ", ParentID
  WRITE(UNIT_SCREEN,'(2X,A,I0)') "ElemID = ", ElemID
  WRITE(UNIT_SCREEN,'(4X,A6,3(2X,A13))') "NodeID", "CoordinateX", "CoordinateY", "CoordinateZ"
  DO iNode=1,aElem%nNodes
    WRITE(UNIT_SCREEN,'(4X,I6,3(2X,SP,ES13.6E2))') &
    aElem%Nodes(iNode)%Node%NodeID, &
    CornerCoords(iNode,1:3)
  END DO
  aSide => aElem%FirstSide
  DO WHILE(ASSOCIATED(aSide))
    IF (ASSOCIATED(aSide%BC)) THEN
      WRITE(UNIT_SCREEN,'(4X,A,I0,1X,A,1X,A,I0,1X,A,1X,A)',ADVANCE='NO') &
        "BCType = ", aSide%BC%BCType, "-", &
        "LocSide = ", aSide%LocSide, "-", &
        "Nodes = "
      DO iNode=1,aSide%nNodes
        WRITE(UNIT_SCREEN,'(I0,1X)',ADVANCE='NO') aSide%Nodes(iNode)%Node%NodeID
      END DO
      WRITE(UNIT_SCREEN,*)
    END IF
    aSide => aSide%NextElemSide
  END DO
  WRITE(UNIT_SCREEN,*)
  aElem => aElem%NextElem
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE PrintElemList
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateFaceNodes(FaceNodes,FaceID,nNodes,NodeID)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodes),POINTER,INTENT(INOUT) :: FaceNodes
INTEGER,INTENT(IN)                     :: FaceID
INTEGER,INTENT(IN)                     :: nNodes
INTEGER,INTENT(IN)                     :: NodeID(1:nNodes)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

ALLOCATE(FaceNodes)

NULLIFY(FaceNodes%PrevFaceNodes)
NULLIFY(FaceNodes%NextFaceNodes)

FaceNodes%FaceID = FaceID

ALLOCATE(FaceNodes%NodeID(1:nNodes))
FaceNodes%NodeID(1:nNodes) = NodeID(1:nNodes)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateFaceNodes
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE DestructFaceNodesList(FaceNodesList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodesList),INTENT(INOUT) :: FaceNodesList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodes),POINTER :: aFaceNodes
TYPE(tFaceNodes),POINTER :: bFaceNodes
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(FaceNodesList%FirstFaceNodes)) THEN
  RETURN
END IF

aFaceNodes => FaceNodesList%FirstFaceNodes
DO WHILE(ASSOCIATED(aFaceNodes))
  bFaceNodes => aFaceNodes%NextFaceNodes
  NULLIFY(aFaceNodes%PrevFaceNodes)
  NULLIFY(aFaceNodes%NextFaceNodes)
  DEALLOCATE(aFaceNodes%NodeID)
  DEALLOCATE(aFaceNodes)
  aFaceNodes => bFaceNodes
END DO

NULLIFY(FaceNodesList%FirstFaceNodes)
NULLIFY(FaceNodesList%LastFaceNodes)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE DestructFaceNodesList
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE AddFaceNodesToList(FaceNodes,FaceNodesList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodes),POINTER,INTENT(INOUT) :: FaceNodes
TYPE(tFaceNodesList),INTENT(INOUT)     :: FaceNodesList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

FaceNodes%PrevFaceNodes => FaceNodesList%LastFaceNodes
NULLIFY(FaceNodes%NextFaceNodes)

IF (.NOT. ASSOCIATED(FaceNodesList%LastFaceNodes)) THEN
  FaceNodesList%FirstFaceNodes => FaceNodes
  FaceNodesList%LastFaceNodes  => FaceNodes
ELSE
  FaceNodesList%LastFaceNodes%NextFaceNodes => FaceNodes
END IF

FaceNodesList%LastFaceNodes => FaceNodes

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE AddFaceNodesToList
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE GetFaceNodesData(FaceNodes,FaceID,NodeID)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodes),POINTER,INTENT(IN) :: FaceNodes
INTEGER,OPTIONAL,INTENT(OUT)        :: FaceID
INTEGER,OPTIONAL,INTENT(OUT)        :: NodeID(:)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

IF (PRESENT(FaceID)) THEN
  FaceID = FaceNodes%FaceID
END IF

IF (PRESENT(NodeID)) THEN
  NodeID(:) = FaceNodes%NodeID(:)
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE GetFaceNodesData
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE PrintFaceNodesList(FaceNodesList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodesList),INTENT(IN) :: FaceNodesList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tFaceNodes),POINTER :: aFaceNodes
!----------------------------------------------------------------------------------------------------------------------!
CHARACTER(LEN=256) :: FormatString
!----------------------------------------------------------------------------------------------------------------------!

FormatString = "(1(2X,I8),4(2X,I8))"

WRITE(UNIT_SCREEN,"(2(2X,A8))") "iFace", "NodeIDs"

aFaceNodes => FaceNodesList%FirstFaceNodes
DO WHILE(ASSOCIATED(aFaceNodes))
  WRITE(UNIT_SCREEN,FormatString) aFaceNodes%FaceID, aFaceNodes%NodeID(:)
  aFaceNodes => aFaceNodes%NextFaceNodes
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE PrintFaceNodesList
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateSide(Side,nNodes)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER,INTENT(INOUT) :: Side
INTEGER,INTENT(IN)                :: nNodes
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iNode
!----------------------------------------------------------------------------------------------------------------------!

ALLOCATE(Side)
ALLOCATE(Side%Nodes(1:nNodes))

DO iNode=1,nNodes
  NULLIFY(Side%Nodes(iNode)%Node)
END DO

Side%nNodes  = nNodes
Side%LocSide = 0
Side%SideID  = 0

NULLIFY(Side%BC)
NULLIFY(Side%NextElemSide)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateSide
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateSides(Elem)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER,INTENT(INOUT) :: Elem
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iNode
INTEGER :: iSide
INTEGER :: nSides
INTEGER :: nNodes
!----------------------------------------------------------------------------------------------------------------------!
INTEGER,ALLOCATABLE :: MapSideToNodes(:,:)
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER :: aSide
!----------------------------------------------------------------------------------------------------------------------!

QuadMapSideToNodes(1,1:2) = (/1,2/)
QuadMapSideToNodes(2,1:2) = (/2,3/)
QuadMapSideToNodes(3,1:2) = (/4,3/)
QuadMapSideToNodes(4,1:2) = (/1,4/)

HexaMapSideToNodes(1,1:4) = (/1,4,3,2/)
HexaMapSideToNodes(2,1:4) = (/1,2,6,5/)
HexaMapSideToNodes(3,1:4) = (/2,3,7,6/)
HexaMapSideToNodes(4,1:4) = (/3,4,8,7/)
HexaMapSideToNodes(5,1:4) = (/1,5,8,4/)
HexaMapSideToNodes(6,1:4) = (/5,6,7,8/)

nSides = 6
nNodes = 4
ALLOCATE(MapSideToNodes(1:nSides,1:nNodes))
MapSideToNodes = HexaMapSideToNodes

DO iSide=1,nSides
  IF (iSide .EQ. 1) THEN
    CALL CreateSide(Elem%FirstSide,nNodes)
    aSide => Elem%FirstSide
  ELSE
    CALL CreateSide(aSide%NextElemSide,nNodes)
    aSide => aSide%NextElemSide
  END IF
  aSide%LocSide = iSide
  DO iNode=1,aSide%nNodes
    aSide%Nodes(iNode)%Node => Elem%Nodes(MapSideToNodes(iSide,iNode))%Node
    aSide%Nodes(iNode)%Node%RefCount = aSide%Nodes(iNode)%Node%RefCount+1
  END DO
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateSides
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateBC(BC)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tBC),POINTER,INTENT(INOUT) :: BC
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

ALLOCATE(BC)

BC%BCType     = 0
BC%BCState    = 0
BC%BCalphaInd = 0
BC%BCIndex    = 0

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateBC
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CopyBC(BCSide,Side)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER,INTENT(IN)    :: BCSide
TYPE(tSide),POINTER,INTENT(INOUT) :: Side
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

CALL CreateBC(Side%BC)

Side%BC%BCType     = BCSide%BC%BCType     
Side%BC%BCState    = BCSide%BC%BCState    
Side%BC%BCalphaInd = BCSide%BC%BCalphaInd 
Side%BC%BCIndex    = BCSide%BC%BCIndex    

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CopyBC
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CreateHexaElem(Elem,NGeo,CurvedNode,ElemID,ParentID)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER,INTENT(INOUT) :: Elem
INTEGER,INTENT(IN)                :: NGeo
TYPE(tNodePtr),INTENT(IN)         :: CurvedNode(0:NGeo,0:NGeo,0:NGeo)
INTEGER,OPTIONAL,INTENT(IN)       :: ElemID
INTEGER,OPTIONAL,INTENT(IN)       :: ParentID
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: nNodes
!----------------------------------------------------------------------------------------------------------------------!
INTEGER,ALLOCATABLE :: HexaMap(:,:)
!----------------------------------------------------------------------------------------------------------------------!

CALL CreateElem(Elem)

nNodes      = 8
Elem%nNodes = nNodes

IF (PRESENT(ElemID)) THEN
  Elem%ElemID   = ElemID
  Elem%TreeID   = ElemID
  Elem%ParentID = ElemID
END IF

Elem%Level    = 0
Elem%nPoints  = 0
Elem%nFacets  = 0
Elem%LocChild = 0

ALLOCATE(Elem%Coords(1:3))
Elem%Coords(1:3) = (/0,0,0/)

CALL BuildHexaMap(NGeo,nNodes,HexaMap)
ALLOCATE(Elem%Nodes(Elem%nNodes))
Elem%Nodes(1)%Node => CurvedNode(0   ,0   ,0   )%Node
Elem%Nodes(2)%Node => CurvedNode(NGeo,0   ,0   )%Node
Elem%Nodes(3)%Node => CurvedNode(NGeo,NGeo,0   )%Node
Elem%Nodes(4)%Node => CurvedNode(0   ,NGeo,0   )%Node
Elem%Nodes(5)%Node => CurvedNode(0   ,0   ,NGeo)%Node
Elem%Nodes(6)%Node => CurvedNode(NGeo,0   ,NGeo)%Node
Elem%Nodes(7)%Node => CurvedNode(NGeo,NGeo,NGeo)%Node
Elem%Nodes(8)%Node => CurvedNode(0   ,NGeo,NGeo)%Node

CALL CreateSides(Elem)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CreateHexaElem
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE RemoveElem(Elem,ElemList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER,INTENT(INOUT) :: Elem
TYPE(tElemList),INTENT(INOUT)     :: ElemList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iNode
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER :: aSide
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(Elem)) THEN
  RETURN
END IF

DO WHILE (ASSOCIATED(Elem%FirstSide))
  aSide => Elem%FirstSide
  CALL RemoveSide(aSide,Elem%FirstSide)
END DO

IF (ASSOCIATED(Elem%Nodes)) THEN
  DO iNode=1,Elem%nNodes
    CALL RemoveNode(Elem%Nodes(iNode)%Node)
  END DO
  DEALLOCATE(Elem%Nodes)
END IF

CALL DisconnectElem(Elem,ElemList)

DEALLOCATE(Elem)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE RemoveElem
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE DisconnectElem(Elem,ElemList)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER,INTENT(INOUT) :: Elem
TYPE(tElemList),INTENT(INOUT)     :: ElemList
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(Elem)) THEN
  RETURN
END IF

IF (ASSOCIATED(Elem%PrevElem)) THEN
  Elem%PrevElem%NextElem => Elem%NextElem
ELSE
  ElemList%FirstElem => Elem%NextElem
END IF

IF (ASSOCIATED(Elem%NextElem)) THEN
  Elem%NextElem%PrevElem => Elem%PrevElem
ELSE
  ElemList%LastElem => Elem%PrevElem
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE DisconnectElem
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE RemoveSide(Side,FirstSide)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER,INTENT(INOUT) :: Side
TYPE(tSide),POINTER,INTENT(INOUT) :: FirstSide
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iNode
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER :: aFirstSide
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(Side)) THEN
  RETURN
END IF

aFirstSide => FirstSide

CALL DisconnectSide(Side,aFirstSide)

IF (ASSOCIATED(Side%BC)) THEN
  CALL RemoveBC(Side%BC)
END IF

IF (ASSOCIATED(Side%Nodes)) THEN
  DO iNode=1,Side%nNodes
    CALL RemoveNode(Side%Nodes(iNode)%Node)
  END DO
  DEALLOCATE(Side%Nodes)
END IF

IF (ASSOCIATED(Side)) THEN
  DEALLOCATE(Side)
END IF

FirstSide => aFirstSide

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE RemoveSide
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE DisconnectSide(Side,FirstSide)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER,INTENT(IN)    :: Side
TYPE(tSide),POINTER,INTENT(INOUT) :: FirstSide
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tSide),POINTER :: aSide
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(Side)) THEN
  RETURN
END IF

IF (ASSOCIATED(FirstSide,Side)) THEN
  FirstSide => Side%NextElemSide
ELSE
  aSide => FirstSide
  DO WHILE (ASSOCIATED(aSide%NextElemSide))
    IF (ASSOCIATED(aSide%NextElemSide,Side)) THEN
      aSide%NextElemSide => Side%NextElemSide
      EXIT
    END IF
    aSide => aSide%NextElemSide
  END DO
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE DisconnectSide
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE RemoveNode(Node)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tNode),POINTER,INTENT(INOUT) :: Node
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

IF (.NOT. ASSOCIATED(Node)) THEN
  RETURN
END IF

Node%RefCount = Node%RefCount-1

IF (Node%RefCount .LE. 0) THEN
  NULLIFY(Node)
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE RemoveNode
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE RemoveBC(BC)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tBC),POINTER,INTENT(INOUT) :: BC
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

DEALLOCATE(BC)
NULLIFY(BC)

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE RemoveBC
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE BuildHexaMap(NGeo,nNodes,HexaMap,HexaMapInv)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
INTEGER,INTENT(IN)                       :: NGeo
INTEGER,INTENT(OUT)                      :: nNodes
INTEGER,ALLOCATABLE,INTENT(OUT)          :: HexaMap(:,:)
INTEGER,ALLOCATABLE,OPTIONAL,INTENT(OUT) :: HexaMapInv(:,:,:)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: i,j,k
INTEGER :: iNode
!----------------------------------------------------------------------------------------------------------------------!

nNodes = (NGeo+1)**3
ALLOCATE(HexaMap(1:nNodes,1:3))

IF (NGeo .EQ. 1) THEN
  HexaMap(1,1:3) = (/0,0,0/)
  HexaMap(2,1:3) = (/1,0,0/)
  HexaMap(3,1:3) = (/1,1,0/)
  HexaMap(4,1:3) = (/0,1,0/)
  HexaMap(5,1:3) = (/0,0,1/)
  HexaMap(6,1:3) = (/1,0,1/)
  HexaMap(7,1:3) = (/1,1,1/)
  HexaMap(8,1:3) = (/0,1,1/)
  RETURN
END IF

iNode = 0
DO k=0,NGeo
  DO j=0,NGeo
    DO i=0,NGeo
      iNode = iNode+1
      HexaMap(iNode,1:3) = (/i,j,k/)
    END DO
  END DO
END DO

IF(PRESENT(HexaMapInv))THEN
  ALLOCATE(HexaMapInv(0:NGeo,0:NGeo,0:NGeo))
  HexaMapInv=0
  iNode=0
  DO k=0,NGeo
    DO j=0,NGeo
      DO i=0,NGeo
        iNode = iNode+1
        HexaMapInv(i,j,k) = iNode
      END DO
    END DO 
  END DO 
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE BuildHexaMap
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CountNodes(ElemList,nNodes)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElemList),INTENT(IN) :: ElemList
INTEGER,INTENT(INOUT)      :: nNodes
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iNode
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
!----------------------------------------------------------------------------------------------------------------------!

! Compute nNodes
nNodes = 0
aElem => ElemList%FirstElem
DO WHILE (ASSOCIATED(aElem))
  DO iNode=1,aElem%nNodes
    IF (aElem%Nodes(iNode)%Node%NodeID .GT. nNodes) THEN
      nNodes = aElem%Nodes(iNode)%Node%NodeID
    END IF
  END DO
  aElem => aElem%NextElem
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CountNodes
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CountElems(ElemList,nElems)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElemList),INTENT(IN) :: ElemList
INTEGER,INTENT(INOUT)      :: nElems
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
!----------------------------------------------------------------------------------------------------------------------!

! Compute nElems
nElems = 0
aElem => ElemList%FirstElem
DO WHILE(ASSOCIATED(aElem))
  nElems = nElems+1
  aElem => aElem%NextElem
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CountElems
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CountElemID(ElemList,ElemID)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElemList),INTENT(IN) :: ElemList
INTEGER,INTENT(INOUT)      :: ElemID
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
!----------------------------------------------------------------------------------------------------------------------!

! Compute nElems
ElemID = 0
aElem => ElemList%FirstElem
DO WHILE(ASSOCIATED(aElem))
  ElemID = ElemID+1
  aElem => aElem%NextElem
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CountElemID
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CountElemsByLevel(ElemList,MaxLevel,nElems)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElemList),INTENT(IN)        :: ElemList
INTEGER,INTENT(IN)                :: MaxLevel
INTEGER,INTENT(INOUT),ALLOCATABLE :: nElems(:)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
!----------------------------------------------------------------------------------------------------------------------!

IF (ALLOCATED(nElems)) THEN
  DEALLOCATE(nElems)
END IF
ALLOCATE(nElems(0:MaxLevel))
nElems = 0

! Compute nElems
aElem => ElemList%FirstElem
DO WHILE(ASSOCIATED(aElem))
  nElems(aElem%Level) = nElems(aElem%Level)+1
  aElem => aElem%NextElem
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CountElemsByLevel
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE CountBCFaces(ElemList,nBCFaces)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElemList),INTENT(IN) :: ElemList
INTEGER,INTENT(INOUT)      :: nBCFaces
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
TYPE(tElem),POINTER :: aElem
TYPE(tSide),POINTER :: aSide
!----------------------------------------------------------------------------------------------------------------------!

! Compute nBCFaces
nBCFaces = 0
aElem => ElemList%FirstElem
DO WHILE (ASSOCIATED(aElem))
  aSide => aElem%FirstSide
  DO WHILE(ASSOCIATED(aSide))
    IF (ASSOCIATED(aSide%BC) .EQV. .TRUE.) THEN
      nBCFaces = nBCFaces+1
    END IF
    aSide => aSide%NextElemSide
  END DO
  aElem => aElem%NextElem
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE CountBCFaces
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE SetAndCountNodeID(iNodeID,jNodeID)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
INTEGER,INTENT(INOUT) :: iNodeID
INTEGER,INTENT(INOUT) :: jNodeID
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!

IF (iNodeID .EQ. 0) THEN
  jNodeID = jNodeID+1
  iNodeID = jNodeID
END IF

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE SetAndCountNodeID
!======================================================================================================================!
!
!
!
!======================================================================================================================!
SUBROUTINE GetQuad4QuadMap(Quad4QuadMap)
!----------------------------------------------------------------------------------------------------------------------!
IMPLICIT NONE
!----------------------------------------------------------------------------------------------------------------------!
! FORMAL ARGUMENTS
!----------------------------------------------------------------------------------------------------------------------!
INTEGER,INTENT(OUT) :: Quad4QuadMap(1:2,1:6,1:9)
!----------------------------------------------------------------------------------------------------------------------!
! LOCAL VARIABLES
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: iSide
INTEGER :: iNode
!----------------------------------------------------------------------------------------------------------------------!
INTEGER :: SideToNodes(1:6,1:4)
INTEGER :: SideToChildren(1:6,1:4)
INTEGER :: NodesIndex(1:2,1:9)
INTEGER :: Order(1:4)
!----------------------------------------------------------------------------------------------------------------------!

SideToChildren(1,1:4) = (/1,3,2,4/)
SideToChildren(2,1:4) = (/1,2,5,6/)
SideToChildren(3,1:4) = (/2,4,6,8/)
SideToChildren(4,1:4) = (/4,3,8,7/)
SideToChildren(5,1:4) = (/1,5,3,7/)
SideToChildren(6,1:4) = (/5,6,7,8/)

SideToNodes(1,1:4) = (/1,4,3,2/)
SideToNodes(2,1:4) = (/1,2,6,5/)
SideToNodes(3,1:4) = (/2,3,7,6/)
SideToNodes(4,1:4) = (/3,4,8,7/)
SideToNodes(5,1:4) = (/1,5,8,4/)
SideToNodes(6,1:4) = (/5,6,7,8/)

NodesIndex(1,1:9) = (/1,2,3,4,1,2,3,4,1/)
NodesIndex(2,1:9) = (/1,2,3,4,2,3,4,1,3/)

Order(1:4) = (/1,2,4,3/)

DO iSide=1,6
  DO iNode=1,9
    Quad4QuadMap(1,iSide,iNode) = SideToChildren(iSide,Order(NodesIndex(1,iNode)))
    Quad4QuadMap(2,iSide,iNode) = SideToNodes(iSide,NodesIndex(2,iNode))
  END DO
END DO

!----------------------------------------------------------------------------------------------------------------------!
END SUBROUTINE GetQuad4QuadMap
!======================================================================================================================!
!
!
!
!----------------------------------------------------------------------------------------------------------------------!
END MODULE MOD_MeshMainMethods
!======================================================================================================================!
